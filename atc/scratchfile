package main

import (
	"errors"
	"flag"
	"fmt"
	"log"
	"math"
	"net/http"
	"sync"
	"time"

	_ "expvar"

	"github.com/tarm/serial"
)

//OUTPUTS
const ATCOrientPin = 1
const ATCRotateForwardRapidPin = 2
const ATCRotateReverseRapidPin = 3
const ATCRotateForwardSlowPin = 4
const ATCRotateReverseSlowPin = 5
const ATCAdvanceRapidPin = 6
const ATCRetractRapidPin = 7
const ATCAdvanceSlowPin = 8
const ATCRetractSlowPin = 9
const ATCInPin = 10
const ATCoutPin = 11
const UnclampPin = 12
const SpindleToolUnClampPin = 13
const SpindleToolClampPin = 14
const SpindleGearLowPin = 15
const SpindleGearHighPin = 16

//INPUTS
const ATCOrientPinRetractedLSPin = 0
const ATCOrientPinInsertedLSPin = 1
const ATCRotateForwardRapidLSPin = 2
const ATCRotateReverseRapidLSPin = 3
const ATCAdvanceRapidLSPin = 4
const ATCRetractRapidLSPin = 5
const ATCAdvanceSlowLSPin = 6
const ATCRetractSlowLSPin = 7
const ATCInLSPin = 8
const ATCOutLSPin = 9
const SpindleToolUnClampLSPin = 10
const SpindleToolClampLSPin = 11
const SpindleGearHighLSPin = 12
const SpindleGearLowLSPin = 13
const ATCPositionBit0Pin = 16
const ATCPositionBit1Pin = 17
const ATCPositionBit2Pin = 18
const ATCPositionBit3Pin = 19
const ATCPositionBit4Pin = 20
const ATCPositionBit5Pin = 21
const ATCPositionBit6Pin = 22

var ErrFailedRead = errors.New("Failed io Read")

var mesa device

// type state struct {
// 	inputs  uint32
// 	outputs uint32
// }

type device struct {
	sync.Mutex
	// read        chan state
	// write       chan uint32
	// readSelect  chan chan uint32
	// writeSelect chan chan uint32
	name    string
	version string
	port    *serial.Port
	buf     []byte
}

var dev string
var baud int

func init() {
	flag.StringVar(&dev, "dev", "/dev/ttyUSB0", "7i64 USB PORT")
	flag.IntVar(&baud, "baud", 115200, "Baud Rate")
}

func main() {
	flag.Parse()
	mesa = newDevice()

	go mesa.run()

	http.ListenAndServe(":1234", nil)

}

func (d *device) run() {
	for state := Standby; state != nil; {
		state = state(d)
	}
}

// func (d *device) pollMesa() {
// 	for {
// 		time.Sleep(time.Millisecond * 1)
// 		d.DigitalRead()
// 	}
// }

// func (d *device) Queue() {
// 	for {
// 		select {
// 		case <-d.readSelect:
// 			d.DigitalRead()
// 		case <-d.writeSelect:
// 			fmt.Println("Write")
// 		}
// 	}
// }

func newDevice() device {
	c := &serial.Config{Name: dev, Baud: baud}
	s, err := serial.OpenPort(c)
	if err != nil {
		log.Fatal(err)
	}

	mesa := device{
		// read:        make(chan state),
		// write:       make(chan uint32),
		// readSelect:  make(chan chan uint32),
		// writeSelect: make(chan chan uint32),
		name: "7i64",
		port: s,
		// buf:  make([]byte, 16),
	}

	_, err = s.Write([]byte{0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08})
	if err != nil {
		log.Println("Write Error")
	}
	time.Sleep(time.Millisecond * 200)
	return mesa
}

func (d *device) DigitalWrite(pin int, state string) error {
	var on bool
	switch state {
	case "ON":
		on = true
	case "OFF":
		on = false
	default:
		return errors.New("invalid state")
	}
	// for i := 0; i < len(d.buf); i++ {
	// 	d.buf[i] = 0x00
	// }
	// buf := make([]byte, 8)
	inbuf := make([]byte, 8)
	outbuf := make([]byte, 8)
	d.Lock()
	defer d.Unlock()
	for n := 0; n != 4; {
		d.port.Flush()
		_, err := d.port.Write([]byte{0x46, 0x00, 0x00})
		if err != nil {
			log.Println("Command Error")
			return err
		}
		time.Sleep(time.Millisecond * 3)

		n, err = d.port.Read(outbuf)
		// fmt.Printf("%d %32.32b\n", n, buf)
		// outbuf := buf
		outputs := uint32(outbuf[3])<<24 + uint32(outbuf[2])<<16 + uint32(outbuf[1])<<8 + uint32(outbuf[0])
		fmt.Printf("%d out: %32.32b\n", n, outputs)
	}

// 	for n := 0; n != 4; {
// 		d.port.Flush()
// 		_, err := d.port.Write([]byte{0x46, 0x04, 0x00})
// 		if err != nil {
// 			log.Println("Command Error")
// 			return err
// 		}
// 		time.Sleep(time.Millisecond * 3)

// 		n, err = d.port.Read(inbuf)
// 		// fmt.Printf("%d %32.32b\n", n, buf)
// 		// inbuf := buf
// 		inputs := uint32(inbuf[3])<<24 + uint32(inbuf[2])<<16 + uint32(inbuf[1])<<8 + uint32(inbuf[0])
// 		fmt.Printf("%d in:  %32.32b\n", n, inputs)
// 	}

// 	if inbuf[3] == 0x08 {
// 		// fmt.Printf("%4.4x\n", inbuf)
// 		log.Println("Watchdog Trip")
// 		outbuf = make([]byte, 8)
// 	}

// 	if on {
// 		outbuf[pin/8] |= (1 << uint(pin%8))
// 	} else {
// 		outbuf[pin/8] &= ^(1 << uint(pin%8))
// 	}

// 	_, err := d.port.Write([]byte{0x66, 0x00, 0x00, outbuf[0], outbuf[1], outbuf[2], 0x08})

// 	if err != nil {
// 		return err
// 	}
// 	return nil
// }

// func (d *device) DigitalRead() {
// 	d.Lock()
// 	defer d.Unlock()
// 	buf := make([]byte, 8)
// 	for n := 0; n != 4; {
// 		d.port.Flush()
// 		_, err := d.port.Write([]byte{0x46, 0x04, 0x00})
// 		if err != nil {
// 			log.Println("Command Error")
// 		}
// 		n, err = d.port.Read(buf)
// 	}
// 	in := uint32(buf[3])<<24 + uint32(buf[2])<<16 + uint32(buf[1])<<8 + uint32(buf[0])

// 	fmt.Printf("in:  %32.32b\n", in)

// 	for n := 0; n != 4; {
// 		d.port.Flush()
// 		_, err := d.port.Write([]byte{0x46, 0x00, 0x00})
// 		if err != nil {
// 			log.Println("Command Error")
// 		}
// 		n, err = d.port.Read(buf)
// 	}
// 	// Update Watchdog
// 	_, err := d.port.Write([]byte{0x66, 0x00, 0x00, d.buf[0], d.buf[1], d.buf[2], 0x08})

// 	if err != nil {
// 		log.Println(err)
// 	}

// 	out := uint32(buf[3])<<24 + uint32(buf[2])<<16 + uint32(buf[1])<<8 + uint32(buf[0])
// 	fmt.Printf("out: %32.32b\n", out)

// }

func (d *device) readIO() (IO, error) {
	d.Lock()
	defer d.Unlock()
	inbuf := make([]byte, 8)
	outbuf := make([]byte, 8)

	// Read Inputs
	for n := 0; n != 4; {
		d.port.Flush()
		_, err := d.port.Write([]byte{0x46, 0x04, 0x00})
		if err != nil {
			log.Println("Command Error")
		}
		time.Sleep(time.Millisecond * 3)
		n, err = d.port.Read(inbuf)
	}
	in := uint32(inbuf[3])<<24 + uint32(inbuf[2])<<16 + uint32(inbuf[1])<<8 + uint32(inbuf[0])

	// fmt.Printf("in:  %32.32b\n", in)

	// Read Outputs
	for n := 0; n != 4; {
		d.port.Flush()
		_, err := d.port.Write([]byte{0x46, 0x00, 0x00})
		if err != nil {
			log.Println("Command Error")
		}
		time.Sleep(time.Millisecond * 3)
		n, err = d.port.Read(outbuf)
	}
	out := uint32(outbuf[3])<<24 + uint32(outbuf[2])<<16 + uint32(outbuf[1])<<8 + uint32(outbuf[0])

	// Update Watchdog
	_, err := d.port.Write([]byte{0x66, 0x00, 0x00, outbuf[0], outbuf[1], outbuf[2], 0x08})
	time.Sleep(time.Millisecond * 3)
	if err != nil {
		log.Println(err)
	}

	// out := uint32(buf[3])<<24 + uint32(buf[2])<<16 + uint32(buf[1])<<8 + uint32(buf[0])
	// fmt.Printf("out: %32.32b\n", out)
	var io IO
	io.inputs = in
	io.outputs = out
	return io, nil

}

func getDirection(startPos, endPos uint8) (string, error) {
	numberOfPositions := 20.0
	if startPos == 0 || startPos > uint8(numberOfPositions) || startPos < 1 {
		return "No Rotation", errors.New("Error: ATC Direction Start Position invalid")
	}
	if endPos == 0 || endPos > uint8(numberOfPositions) || endPos < 1 {
		return "No Rotation", errors.New("Error: ATC Direction End Position invalid")
	}
	if startPos == endPos {
		return "No Rotation", nil
	}
	distance := math.Abs(float64(startPos - endPos))
	lessThanHalf := distance < numberOfPositions/2

	if lessThanHalf && (endPos < startPos) || !lessThanHalf && (endPos > startPos) {
		return "Reverse", nil
	} else {
		return "Forward", nil
	}
}

func atcToolSelect(nextPos uint8) {
	currentPos, err := atcReadPosition()
	if err != nil {
		log.Fatalf("%s\n", err)
	}

	direction, err := getDirection(currentPos, nextPos)
	if err != nil {
		log.Fatalf("%s\n", err)
	}

	if direction == "No Rotation" {
		return
	}

	err = atcOrientPin("retract")
	if err != nil {
		log.Fatalf("%s\n", err)
	}

	for currentPos != nextPos {
		currentPos, err = atcRotateCaddy(direction)
		if err != nil {
			log.Fatalf("%s\n", err)
		}
	}

	err = atcOrientPin("advance")
	if err != nil {
		log.Fatalf("%s\n", err)
	}

}

func atcOrientPin(direction string) error {
	return nil
}

func atcRotateCaddy(direction string) (uint8, error) {
	return 0, nil
}

func atcReadPosition() (uint8, error) {
	return 0, nil
}

var ErrNotBCD = errors.New("Byte is Not BCD Encoded")

// uint8 to Packed BCD 8-4-2-1 One digit per nibble
func Uint8toBCD(u uint8) byte {
	lsn := u % 10
	u /= 10
	msn := u % 10
	return ((msn & 0xf) << 4) | (lsn & 0xf)
}

// Packed BCD 8-4-2-1 One digit per nibble to uint8
// Error if not a BCD digits
func BCDtoUint8(bcd byte) (uint8, error) {
	digits := uint8((bcd>>4&0xf)*10 + (bcd & 0xf))
	// Confirm input is BCD encoded as expected
	check := Uint8toBCD(digits)

	if bcd != check|bcd {
		return digits, ErrNotBCD
	}
	return digits, nil
}

func (d *device) getStatus() byte {
	d.Lock()
	defer d.Unlock()

	d.port.Flush()
	n, err := d.port.Write([]byte{0xC0})
	if err != nil {
		log.Println("Command Error")
	}
	time.Sleep(time.Millisecond * 3)
	n, err = d.port.Read(d.buf)
	fmt.Printf("%d %8.8b\n", n, d.buf[0])
	return d.buf[0]

}

func (d *device) getTimeout() byte {
	d.Lock()
	defer d.Unlock()

	d.port.Flush()
	n, err := d.port.Write([]byte{0xCB})
	if err != nil {
		log.Println("Command Error")
	}
	time.Sleep(time.Millisecond * 3)
	n, err = d.port.Read(d.buf)
	fmt.Printf("%d %8.8b\n", n, d.buf[0])
	return d.buf[0]

}

// func changeTool(tool uint8) {

// 	MagazineAdvanceSlow()
// 	MagazineAdvanceRapid()
// 	MagazineAdvanceSlow()
// 	SpindleToolUnclamp()
// 	MagazineDown()
// 	for tool != current {
// 		OrientPinRetract()
// 		MagazineRotateRapid()
// 		MagazineRotateSlow()
// 		current = MagazineReadPosition()
// 	}
// 	MagazineOrientPinInsert()
// 	MagazineUp()
// 	SpindleToolClamp()
// 	MagazineRetractSlow()
// 	MagazineRetractRapid()
// 	MagazineRetractSlow()

// }

// func timerExamle() {
// 	timeout := time.NewTimer(time.Second).C

// 	pollTimer := time.NewTicker(time.Millisecond * 40).C

// 	for {
// 		select {
// 		case <-timeout:
// 			fmt.Println("TimedOut")
// 			return
// 		case <-pollTimer:
// 			fmt.Println("Ticker ticked")
// 		}
// 	}
// }
type IO struct {
	inputs  uint32
	outputs uint32
}

type stateFn func(d *device) stateFn

func Standby(d *device) stateFn {
	log.Println("Standby")
	nextState := make(chan stateFn)
	errorChan := make(chan error)

	go func() {
		io, err := d.readIO()
		if err != nil {
			errorChan <- err
		}
		fmt.Printf("out: %32.32b\n", io.outputs)
		fmt.Printf("in:  %32.32b\n", io.inputs)
		currentATCState := determineState(io)
		nextState <- currentATCState
	}()

	for {
		select {
		case <-time.After(time.Millisecond * 50):
			fmt.Println("TimedOut")
			return nil
		case state := <-nextState:
			return state
		case err := <-errorChan:
			log.Println(err)
			return nil
		}
	}
}

// type pins struct {
// 	name  string
// 	pin   uint8
// 	state bool
// }

var pin = map[string]uint8{
	"ATCOrientPinRetractedLSPin": 0,
	"ATCOrientPinInsertedLSPin":  1,
	"ATCRotateForwardRapidLSPin": 2,
	"ATCRotateReverseRapidLSPin": 3,
	"ATCAdvanceRapidLSPin":       4,
	"ATCRetractRapidLSPin":       5,
	"ATCAdvanceSlowLSPin":        6,
	"ATCRetractSlowLSPin":        7,
	"ATCInLSPin":                 8,
	"ATCOutLSPin":                9,
	"SpindleToolUnClampLSPin":    10,
	"SpindleToolClampLSPin":      11,
	"SpindleGearHighLSPin":       12,
	"SpindleGearLowLSPin":        13,
	"ATCPositionBit0Pin":         16,
	"ATCPositionBit1Pin":         17,
	"ATCPositionBit2Pin":         18,
	"ATCPositionBit3Pin":         19,
	"ATCPositionBit4Pin":         20,
	"ATCPositionBit5Pin":         21,
	"ATCPositionBit6Pin":         22,
}

func determineState(io IO) stateFn {

	var atcbyte byte
	atcbyte = byte(io.inputs & (1 << ATCPositionBit0Pin))
	atcbyte += byte(io.inputs & (1 << ATCPositionBit1Pin) << 1)
	atcbyte += byte(io.inputs & (1 << ATCPositionBit2Pin) << 2)
	atcbyte += byte(io.inputs & (1 << ATCPositionBit3Pin) << 3)
	atcbyte += byte(io.inputs & (1 << ATCPositionBit4Pin) << 4)
	atcbyte += byte(io.inputs & (1 << ATCPositionBit5Pin) << 5)
	atcbyte += byte(io.inputs & (1 << ATCPositionBit6Pin) << 6)
	pos, err := BCDtoUint8(atcbyte)
	if err != nil {
		fmt.Println(err)
	}
	fmt.Println("ATC Position: ", pos)

	// var OrientPinInserted bool
	// var MagazineUP bool
	// var MagazineRetracted bool
	// var ToolClamped bool
	// var LowGear bool

	// if OrientPinInserted && MagazineUP && MagazineRetracted {
	// 	return Standby
	// }

	// if !OrientPinInserted

	// !((io.inputs & (1 << ATCOrientPinRetractedLSPin))> 0)

	// for key, value := range pin {
	// 	hasbit := io.inputs & (1 << value)
	// 	isON := (hasbit > 0)
	// 	fmt.Println(key, isON)
	// }

	return Standby
}

// func ToolSelected() stateFn {
// 	log.Println("ToolSelected")
// 	log.Panic("Finished")
// 	return StandBy
// }

// func MagazineAdvanceSlowStart(tool uint8) stateFn {
// 	log.Println("Starting MagazineAdvanceSlowStart")
// 	//read current state
// 	inputs, outputs, err := readState()
// 	if err != nil {
// 		fmt.Println("TimedOut")
// 		return Error
// 	}

// 	// Check if we need to move
// 	currentPosition := currentPosition(inputs)
// 	if tool == currentPosition {
// 		return ToolSelected
// 	}

// 	// and confirm we are in standby Ready
// 	ready := checkReady(inputs, outputs)

// 	if !ready {
// 		return Error
// 	}

// 	if ready {
// 		timeout := time.NewTimer(time.Second)
// 		pollTimer := time.NewTicker(time.Millisecond * 6)

// 		inputs, outputs, err = DigitalWrite(ATCAdvanceSlow, "ON")
// 		inSlowZone := checkAdvanceSlow(inputs, outputs)
// 		for inSlowZone {
// 			select {
// 			case <-timeout:
// 				fmt.Println("TimedOut")
// 				return Error
// 			case <-pollTimer:
// 				inputs, outputs, err = readState()
// 				if err != nil {
// 					log.Println(err)
// 					return Error
// 				}
// 				inSlowZone = checkAdvanceZone(inputs, outputs)
// 			}

// 		}
// 		return MagazineAdvanceRapid
// 	}
// 	return Error
// }
// func MagazineAdvanceRapid() stateFn {
// 	log.Println("Starting MagazineAdvanceRapid")

// 	// Turn on ATCAdvanceRapid

// 	inputs, outputs, err := DigitalWrite(ATCAdvanceRapid, "ON")
// 	inputs, outputs, err = DigitalWrite(ATCAdvanceSlow, "OFF")

// 	inRapidZone := checkAdvanceZone(inputs, outputs)
// 	for inRapidZone {
// 		inputs, outputs, err = readState()
// 		inRapidZone = checkAdvanceZone(inputs, outputs)
// 	}
// 	return MagazineAdvanceSlowStop

// }
// func MagazineAdvanceSlowStop() stateFn {
// 	log.Println("Starting MagazineAdvanceSlowStop")

// 	// Turn on ATCAdvanceRapid
// 	inputs, outputs, err := DigitalWrite(ATCAdvanceSlow)
// 	inSlowZone := checkAdvanceZone(inputs, outputs)
// 	for inSlowZone {
// 		inputs, outputs, err = readState()
// 		inSlowZone = checkAdvanceZone(inputs, outputs)
// 	}
// 	return MagazineAdvanceStop
// }

// func MagazineGripTool() stateFn {
// 	log.Println("MagazineGripTool")
// 	inputs, outputs, err := readState()
// 	// Check State

// 	return UnclampTool
// }

// func UnclampTool() stateFn {
// 	inputs, outputs, err := DigitalWrite(SpindleToolUnClamp, "ON")

// }
// func MagazineDown() stateFn {

// }
// func OrientPinRetract() stateFn {

// }
// func MagazineRotateRapid() stateFn {

// }
// func MagazineRotateSlow() stateFn {

// }
// func MagazineReadPosition() stateFn {

// }
// func MagazineOrientPinInsert() stateFn {

// }
// func MagazineUp() stateFn {

// }
// func ClampTool() stateFn {

// }
// func MagazineRetractSlowStart() stateFn {

// }
// func MagazineRetractRapid() stateFn {

// }
// func MagazineRetractSlowStop() stateFn {

// }
